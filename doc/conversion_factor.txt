

Underlying type is a numeric type e.g a rational or a real

conversion factor has a rational multiplier and a rational exponent.

conversion factor with integer exponent (after reduction) is a rational number
conversion factor with a non integer exponent is a real number (? check e.g 1 * 10 ^ 1/2)

in context of quantities representing the same value, where v is the value and k is the conversion_factor

struct q{
  value v;
  conversion_factor k;
}

The value v is the mathematical value of the base_unit * 10 ^k

so in  1mm v == 1, k = -3 , base unit unit value == v * 10 ^-3

q q1, q2;
if ( q1 == q2)
implies
q1.v * q1.k == q2.v * q2.k

example from quan:

lhs outputs as : 1 km
lhs.numeric_value = 1
lhs.conversion_factor.mux = 1
lhs.conversion_factor.exp = 3
converison factor calc = lhs.conversion_factor.mux * pow(10,q_name.conversion_factor.exp)
lhs.conversion_factor = 1000
lhs.normalised value =  1000

rhs outputs as : 1e+06 mm
rhs.numeric_value = 1e+06
rhs.conversion_factor.mux = 1
rhs.conversion_factor.exp = -3
converison factor calc = rhs.conversion_factor.mux * pow(10,q_name.conversion_factor.exp)
rhs.conversion_factor = 0.001
rhs.normalised value =  1000

so  1 * 1000  == 1.e6 * 0.0001

conversion_factor ops

can conversion_factor be zero ? , theoretically yes. May be useful for something?
Is negative multiplier allowed
Negative exponent surely allowed
non integer exponent allowed? - probably

addition - no. It is a factor so only multiplied by, however moving the exponent is probably useful to align
2 conversion factors

scaling - yes

multiplication by other conversion_factor ? yes for q^n

-------------------------------------------

So ops on conversion factor
where K, K1 and K2 are coversion factors
n
K + K1 -> K3 is OK, do we need this?

K * K1 -> K2
K / K1 -> K2

compare(K,K1) -> int // ( result int value as strcmp)

to_runtime(K) -> some numeric type

-------------------
addition/subtraction of 2 numbers with conversion factors
if the conversion factors are not the same, 1 needs scaling

q1 + q2

// Chooose this option
// involves 1 multiplication on runtime numbers
// and 1 add
or  q1.v * (q1.k / q2.k) + q2.v  -> {q3.v , (q3.k == q2.k)}

// Alternative
// N.B involves 2 multiplications on runtime numbers
// and 1 add
q1.v * q1.k + q2.v * q2.k   -> {q3.v , (q3.k == 1)}

For choosing the resulting conversion factor , choose the finest grained.
which is the one with the lowest numeric value

ops on quantity with conversion factor (ignoring dimensional analysis)


q1 + q2;

if ( q1.k == q2.k){
   -> q { q1.v + q2.v, q1.k};
}else{
  if ( q1.k < q2.k) {
    -> q{ q1.v + q2.v * (q1.k / q2.k), q1.k};
  }else{
    -> q{ q1.v * (q2.k/q1.k) + q2.v, q2.k};
  }
}
--------------
q1 - q2 
if ( q1.k == q2.k){
  -> q {q1.v - q2.v, q1.k};
else{
   if (q1.k < q2.k){
      -> -> q{ q1.v - q2.v * (q1.k / q2.k), q1.k}
   }else{
      -> q{ q1.v * (q2.k/q1.k) - q2.v, q2.k};
   }
}
------
q1 * q2
-> q{ q1.v * q2.v , q1.k * q2.k};
-------
q1 / q2
-> q{ q1.v / q2.v , q1.k / q2.k};

q ^ R
-> q{ q1.v^r * q.k ^ R};



















